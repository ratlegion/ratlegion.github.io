<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        const mod = (a, b) => ((a % b) + b) % b;
        const get4Direction = rotation => [3, 1, 0, 2][Math.floor(((rotation % 360) + 360) % 360 / 90)];
        const vectorToDirection = vector => Math.atan2(-vector[1], vector[0]) * (180 / Math.PI) + 90
        // https://stackoverflow.com/questions/9043805/test-if-two-lines-intersect-javascript-function
        const isLineIntersecting = (n, t, r, e) => { function i(n, t, r) { return (r[1] - n[1]) * (t[0] - n[0]) > (t[1] - n[1]) * (r[0] - n[0]) } return i(n, r, e) != i(t, r, e) && i(n, t, r) != i(n, t, e) }
        // https://stackoverflow.com/questions/16005136/how-do-i-see-if-two-rectangles-intersect-in-javascript-or-pseudocode
        const doRectanglesOverlap = (rect1, rect2) => {
            let [left1, top1, right1, bottom1] = [...rect1],
                [left2, top2, right2, bottom2] = [...rect2];
            return !(top1 < bottom2 || top2 < bottom1 || right1 < left2 || right2 < left1);
        }
        const cellsOverlappingSquare = (x, y, r) => {
            const minX = Math.floor(x - r);
            const maxX = Math.floor(x + r);
            const minY = Math.floor(y - r);
            const maxY = Math.floor(y + r);

            let cells = [];

            for (let i = minX; i <= maxX; i++) {
                for (let ii = minY; ii <= maxY; ii++) {
                    cells.push([i, ii]);
                }
            }

            return cells;
        }
        const hexToDirections = num => {
            // bitwise that checks for a bit
            return {
                down: (num & (1 << 0)) !== 0,
                right: (num & (1 << 1)) !== 0,
                left: (num & (1 << 2)) !== 0,
                up: (num & (1 << 3)) !== 0,
            };
        }
        const xyrToRect = (x, y, r) => {
            return [x - r, y + r, x + r, y - r]
        }


        let awaitingLoads = [];

        let assets = { tiles: {}, actors: {} };

        async function initialiseTileset(source, id) {
            awaitingLoads.push(id + "." + source);

            try {
                await new Promise((resolve) => {
                    const initImg = new Image();
                    initImg.src = source;


                    console.log("Tileset load request sent")

                    initImg.onload = () => {
                        //TODO: fix redundant code below
                        const index = awaitingLoads.indexOf(id + "." + source);
                        awaitingLoads.splice(index, 1);

                        assets.tiles[id] = { "img": initImg };

                        console.log("Tileset " + id + " loaded");

                        resolve();
                    };

                    initImg.onerror = (error) => {
                        const index = awaitingLoads.indexOf(id + "." + source);
                        awaitingLoads.splice(index, 1);

                        console.error("Failure to load tileset " + id, error);
                    }
                });
            } catch (error) {
                const index = awaitingLoads.indexOf(id + "." + source);
                awaitingLoads.splice(index, 1);

                console.error("Error while loading tileset " + id, error);
            }
        }
        async function initialiseCharacter(source, id) {
            awaitingLoads.push(id + "." + source);

            try {
                await new Promise((resolve) => {
                    const initImg = new Image();
                    initImg.src = source;


                    console.log("Character load request sent")

                    initImg.onload = () => {
                        //TODO: fix redundant code below
                        const index = awaitingLoads.indexOf(id + "." + source);
                        awaitingLoads.splice(index, 1);

                        assets.actors[id] = { img: initImg, width: initImg.width, height: initImg.width };

                        console.log("Character " + id + " loaded");

                        resolve();
                    };

                    initImg.onerror = (error) => {
                        const index = awaitingLoads.indexOf(id + "." + source);
                        awaitingLoads.splice(index, 1);

                        console.error("Failure to load actor " + id, error)
                    }
                });
            } catch (error) {
                const index = awaitingLoads.indexOf(id + "." + source);
                awaitingLoads.splice(index, 1);

                console.error("Error while loading actor " + id, error)
            }
        }






        const tileCanvas = document.createElement("canvas");
        tileCanvas.width = 480;
        tileCanvas.height = 360;
        tileCanvas.style = `image-rendering: crisp-edges;
transform-origin: top left;
transform: scale(5);
image-rendering: pixelated;`;
        document.body.appendChild(tileCanvas);
        let tileCTX = tileCanvas.getContext("2d");
        tileCTX.imageSmoothingEnabled = false;

        function drawTile(id, index, x, y) {
            const tileSize = game.settings.tileSize; //Hardcoded for now
            const scale = 1.0; //Hardcoded for now
            const tilesetWidth = 8; //Hardcoded for now

            tileCTX.drawImage(
                assets.tiles[id].img,

                ((index - 1) % tilesetWidth) * tileSize,
                Math.floor((index - 1) / tilesetWidth) * tileSize,
                tileSize, tileSize,

                x * scale, y * scale,

                tileSize * scale, tileSize * scale
            );
        }

        function drawTileset(tileset, tiles) {
            const tileSize = game.settings.tileSize;
            for (let i = 0; i < tiles.length; i++) {
                for (let ii = 0; ii < tiles[i].length; ii++) {
                    const currentIndex = tiles[i][ii];
                    if (currentIndex !== 0) drawTile(tileset, tiles[i][ii], ii * tileSize, i * tileSize);
                }
            }
        }

        function drawActor(id, pose, x, y) {
            const tileSize = game.settings.tileSize; //Hardcoded for now
            const scale = 1.0; //Hardcoded for now


            const sprite = game.actors[id];

            if (!sprite) return;

            const spriteSrc = assets.actors[sprite.src];

            const shiftX = sprite.shiftX || 0;
            const shiftY = sprite.shiftY || 0;

            if (sprite.mode === "singleActor") {

            } else if (sprite.mode === "4x4") {
                let direction = 0;
                if (typeof pose.rotation === "number") {

                    direction = get4Direction(pose.rotation);

                } else if (typeof pose.direction === "number") direction = mod(pose.direction, 4);


                let frame = 0;
                if (pose.state === "WALK") {
                    if (typeof pose.frame === "number") frame = pose.frame;
                    frame = Math.floor(mod(frame, 4))
                }


                const spriteWidth = spriteSrc.width / 4;
                const spriteHeight = spriteSrc.height / 4;

                tileCTX.drawImage(
                    spriteSrc.img,

                    spriteWidth * frame, spriteWidth * direction,

                    spriteWidth, spriteHeight,

                    Math.floor(x * tileSize + shiftX),
                    Math.floor(y * tileSize - (spriteHeight / 2) + shiftY),

                    spriteWidth, spriteHeight
                );
            }
        }

        class Actor {
            constructor(actor) {
                this.x = 0;
                this.y = 0;

                this.rotation = 0;

                this.actor = actor;

                this.pose = {};

                this.state = "IDLE";
            }
            toTileCordinates(position) {
                return ([Math.floor(Math.max(position[0] + .5, 0)), Math.floor(Math.max(position[1] + .5, 0))]);
            }
            tileCordinates() {
                return this.toTileCordinates([this.x, this.y]);
            }
            getCollisionAt(tileCordinates) {
                // ?. <- goofy ahh operator that just short returns undefined if the first one is undefined.
                return collisionMap[tileCordinates[1]]?.[tileCordinates[0]] || 0;
            }
            draw() {
                let myPose = this.pose;
                if (this.rotation !== undefined) myPose.rotation = this.rotation;
                myPose.state = this.state;

                myPose.frame = frame / 10;

                drawActor(this.actor, myPose, this.x, this.y);
            }
        }

        class Character extends Actor {
            constructor(id) {
                let spriteInput = activeScene.characters[id].actor;
                super(spriteInput);

                this.id = id || undefined;

                this.x = activeScene.characters[id].x || 0;
                this.y = activeScene.characters[id].y || 0;

                this.rotation = activeScene.characters[id].rotation || 0;

                this.actor = spriteInput || "";

                this.script = activeScene.characters[id].script || {};
            }

            update() {
                //process(this.script)
            }
        }

        class Player extends Actor {
            constructor(id) {
                super(id);

                this.y = 0;
                this.x = 0;
                this.rotation = 180;

            }
            update() {
                const speedMultiplier = 1;

                let tileCordinates = this.tileCordinates();
                let currentTileCollision = hexToDirections(this.getCollisionAt(tileCordinates))

                // console.log(hexToDirections(this.getCollisionAt(tileCordinates)));
                // console.log(mod(this.y + .5, 1))

                const rectangleSize = 0.25; //radius of the square hitbox of the player
                const checkPadding = 1; // add some padding to the radius



                const playerHitbox = xyrToRect(this.x + .5, this.y + .5, rectangleSize)

                const overlaps = cellsOverlappingSquare(this.x + 0.5, this.y + 0.5, (rectangleSize + checkPadding));

                let overlapsCollision = [];
                for (let i = 0; i < overlaps.length; i++) {
                    overlapsCollision.push({
                        collision: hexToDirections(this.getCollisionAt(overlaps[i])), pos: overlaps[i]
                    });
                }


                function getCollisionBoxes(collisions) {
                    let collisionBoxes = [];
                    for (let i = 0; i < collisions.length; i++) {
                        let x = collisions[i].pos[0];
                        let y = collisions[i].pos[1];

                        //I wonder if using bitwise operators would speed this up a little
                        if (collisions[i].collision.left !== true && collisions[i].collision.up !== true && collisions[i].collision.right !== true && collisions[i].collision.down !== true) {
                            collisionBoxes.push([0 + x, 1 + y, 1 + x, 0 + y, "FULL"]);
                        } else {
                            //DOWN
                            if (collisions[i].collision.down !== true) {
                                collisionBoxes.push([0 + x, 1 + y, 1 + x, 1 + y, "UP"]);
                            }
                            //RIGHT
                            if (collisions[i].collision.right !== true) {
                                collisionBoxes.push([1 + x, 1 + y, 1 + x, 0 + y, "RIGHT"]);
                            }
                            //LEFT
                            if (collisions[i].collision.left !== true) {
                                collisionBoxes.push([0 + x, 1 + y, 0 + x, 0 + y, "LEFT"]);
                            }
                            //UP
                            if (collisions[i].collision.up !== true) {
                                collisionBoxes.push([0 + x, 0 + y, 1 + x, 0 + y, "DOWN"]);
                            }
                        }

                    }

                    return (collisionBoxes)
                }
                function hitboxCollidesGrid(boxes, hitbox) {
                    for (let i = 0; i < boxes.length; i++) {
                        if (doRectanglesOverlap(boxes[i], hitbox)) {
                            return true;
                        }
                    }
                    return false
                }


                const collisionBoxes = getCollisionBoxes(overlapsCollision);



                if (!(inputVector[0] === 0 && inputVector[1] === 0)) {
                    let moveMotion = [
                    inputVector[0] / game.settings.tileSize * game.settings.baseWalkSpeed * speedMultiplier,
                    inputVector[1] / game.settings.tileSize * game.settings.baseWalkSpeed * speedMultiplier
                    ];
                    let newPositionX = this.x + moveMotion[0];
                    let newPositionY = this.y - moveMotion[1];

                    const isCurrentValid = !hitboxCollidesGrid(collisionBoxes, playerHitbox)

                    if (isCurrentValid) {
                        const isNewXValid = !hitboxCollidesGrid(collisionBoxes, xyrToRect(newPositionX + .5, this.y + .5, rectangleSize))
                        if (isNewXValid) {
                            if (moveMotion[0] !== 0) {
                                this.x = newPositionX;
                            }
                        }
                        const isNewYValid = !hitboxCollidesGrid(collisionBoxes, xyrToRect(this.x + .5, newPositionY + .5, rectangleSize))
                        if (isNewYValid) {
                            if (moveMotion[1] !== 0) {
                                this.y = newPositionY;
                            }
                        }
                    } else {
                        this.x = newPositionX;
                        this.y = newPositionY;
                    }

                    this.rotation = vectorToDirection(inputVector);

                    this.state = "WALK";
                } else {
                    this.state = "IDLE";
                }



                // // Awful gpt generated debug code
                // {
                //     const centerX = (this.x + 0.5) * 16;
                //     const centerY = (this.y + 0.5) * 16;
                //     const size = (rectangleSize + checkPadding) * 2 * 16;
                //     tileCTX.strokeStyle = '#34baeb55';
                //     tileCTX.lineWidth = 1;
                //     tileCTX.strokeRect(centerX - (rectangleSize + checkPadding) * 16, centerY - (rectangleSize + checkPadding) * 16, size, size);
                // }
                // {
                //     const centerX = (this.x + 0.5) * 16;
                //     const centerY = (this.y + 0.5) * 16;
                //     const size = (rectangleSize) * 2 * 16;
                //     tileCTX.strokeStyle = '#f21d41cc';
                //     tileCTX.lineWidth = 1;
                //     tileCTX.strokeRect(centerX - (rectangleSize) * 16, centerY - (rectangleSize) * 16, size, size);
                // }
                // {
                //     for (let i = 0; i < collisionBoxes.length; i++) {
                //         const [left, top, right, bottom] = collisionBoxes[i];
                //         const width = right - left;
                //         const height = bottom - top;

                //         tileCTX.strokeStyle = 'yellow';

                //         if (collisionBoxes[i][4] == "FULL") tileCTX.strokeStyle = 'red';

                //         if (collisionBoxes[i][4] == "UP") tileCTX.strokeStyle = '#ffff30';
                //         if (collisionBoxes[i][4] == "DOWN") tileCTX.strokeStyle = '#b5b500';
                //         if (collisionBoxes[i][4] == "LEFT") tileCTX.strokeStyle = '#ffe600';
                //         if (collisionBoxes[i][4] == "RIGHT") tileCTX.strokeStyle = '#c8ff00';

                //         tileCTX.fillStyle = '#a1a30d44';
                //         tileCTX.lineWidth = 1;
                //         tileCTX.fillRect(left * 16, top * 16, width * 16, height * 16);
                //         tileCTX.strokeRect(left * 16, top * 16, width * 16, height * 16);
                //     }

                // }


            }
        }


        let actors = [];


        let game;
        let activeScene;
        let collisionMap = [];
        let player;
        async function loadGame(load, func) {
            game = load;
            activeScene = structuredClone(game.scenes[0]);

            // Create a new Character class for each actor in the load.
            actors = [];
            for (let actor in activeScene.characters) {
                actors.push(new Character(actor));
            }

            // Create the player
            player = new Player("lilguy");


            console.log(activeScene.layers)

            //Load the game's tiles into the collision map
            for (let layer of activeScene.layers) {
                const layerTileset = game.tilesets[layer.tileset];

                layer.tiles.forEach((layerY, i) => {
                    if (i > (collisionMap.length - 1)) collisionMap.push([]);

                    layerY.forEach((tile, j) => {
                        if (j > (collisionMap[i].length - 1)) collisionMap[i].push(15);

                        if (typeof tile === "number" && tile > 0) {
                            const tileY = Math.floor((tile - 1) / layerTileset.width);
                            let collisionY = layerTileset.collisions[tileY];
                            if (typeof collisionY === "undefined") collisionY = 15;

                            let collision = collisionY[mod((tile - 1), layerTileset.width)];

                            if (typeof collision === "number") { collisionMap[i][j] = collision };
                        }
                    });
                });

            }

            console.log(collisionMap)

            requestAnimationFrame(gameLoop);

            if (typeof func === "function") func();
        }


        const keysHeld = {};
        document.addEventListener("keydown", updateKeyDown);

        function updateKeyDown(e) {
            keysHeld[e.code] = true;
        }
        document.addEventListener("keyup", updateKeyUp);

        function updateKeyUp(e) {
            keysHeld[e.code] = false;
        }



        let timeOld = performance.now();
        const targetFrameRate = 60;
        const timestep = 1000 / targetFrameRate;
        // I've tried so many things to battle the game slowing down and stuttering,
        // I can't seem to find a perfect solution.
        let timeOver = 0;
        let frame = 0;
        function gameLoop(currentTime) {

            const dT = currentTime - timeOld;

            timeOld = currentTime;
            timeOver += dT;

            while (timeOver >= timestep) {
                // I'm choosing to not use dT for the gameloop,
                // as I want the game to be consistant,
                // but I am supplying it,
                gameUpdate(timestep);
                frame++;
                timeOver -= timestep;
            }

            requestAnimationFrame(gameLoop);
        }


        function gameUpdate(dT) {
            inputProcess();
            drawProcess();
        }



        let inputVector = [0.0, 0.0]
        function inputProcess() {
            let right = ((keysHeld.KeyD === true) - (keysHeld.KeyA === true)) || 0;
            let up = ((keysHeld.KeyW === true) - (keysHeld.KeyS === true)) || 0;

            inputVector = [right, up]
        }

        function drawProcess() {
            tileCTX.clearRect(0, 0, tileCanvas.width, tileCanvas.height);

            for (let i = 0; i < activeScene.layers.length; i++) {
                drawTileset(activeScene.layers[i].tileset, activeScene.layers[i].tiles);
            }

            for (let actor of actors) {
                actor.draw();
            }
            player.update();

            player.draw();
        }


    </script>

    <script type="module">
        await initialiseTileset("src/tileset.png", "grasslands")

        await initialiseCharacter("src/lilguy.png", "lilguy")



        // collisions is stored what part of the directions to move accross are possible. mapping is binary with: down right left up

        // passible : number : impassible
        //          : 0      : ↓→←↑
        // ↓        : 1      : →←↑
        // →        : 2      : ↓←↑
        // ↓→       : 3      : ←↑
        // ←        : 4      : ↓→↑
        // ↓←       : 5      : →↑
        // →←       : 6      : ↓↑
        // ↓→←      : 7      : ↑
        // ↑        : 8      : ↓→←
        // ↓↑       : 9      : →←
        // →↑       : 10     : ↓←
        // ↓→↑      : 11     : ←
        // ←↑       : 12     : ↓→
        // ↓←↑      : 13     : →
        // →←↑      : 14     : ↓
        // ↓→←↑     : 15     :


        await loadGame({
            settings: {
                tileSize: 16,
                baseWalkSpeed: 1
            },
            tilesets: {
                "grasslands": {
                    src: "grasslands",
                    mode: "tileset",
                    size: 16,
                    width: 8,
                    collisions: [
                        [3., 7., 5., 0.],
                        [11, 15, 13],
                        [10, 14, 12],
                        [0., 0., 0.],
                        [0., 0., 0.],
                        [15],
                        [15],
                    ]
                }
            },
            actors: {
                "lilguy": {
                    src: "lilguy",
                    mode: "4x4",
                    shiftY: 0
                }
            },
            scripts: {
                "lilguy": {
                    language: "parscript",
                    script: `
var timesTalked = 0

label("start")

turn(180)

say("Hello adventurer!")

wait(5)

turn(0)

wait(60)

turn(180)


ask("Have you played before?", "Yes", "No"){
    if(timesTalked > 0){
        say("Great! (" + timesTalked + ")")
    } else{
        say("Great!")
    }
    
    timesTalked = timesTalked + 1
    
    jump("start")
} & {
    say("I'll show you the ropes!")

    #tutorial()
}
                    `
                }
            },
            player: {
                sprite: "lilguy",
                x: 1,
                y: 7,
                hitbox: {
                    size: .5,
                    shiftX: 0,
                    shiftY: 0
                }
            },
            scenes: [
                {
                    width: 10,
                    height: 10,
                    scale: 16,
                    layers: [
                        {
                            tileset: "grasslands",
                            tiles: [
                                [1., 2., 2., 2., 2., 3.],
                                [9., 10, 10, 10, 10, 11],
                                [17, 18, 18, 18, 18, 19],
                                [25, 26, 26, 26, 26, 27],
                                [25, 26, 26, 26, 26, 27],
                                [25, 26, 26, 26, 26, 27],
                                [33, 34, 34, 34, 34, 35],
                                [10, 10, 10, 10, 10, 10],
                                [10, 10, 10, 10, 10, 10],
                                [10, 10, 10, 10, 10, 10],
                            ]
                        },
                        {
                            tileset: "grasslands",
                            tiles: [
                                [0],
                                [0, 0, 0, 4],
                                [0, 0, 0, 0, 41],
                                [0, 0, 0, 0, 49],
                                [0, 0, 0, 0, 49],
                                [0, 0, 0, 0, 49],
                                [0, 0, 0, 0, 49],
                            ]
                        }
                    ],
                    characters: {
                        "lilguy": {
                            actor: "lilguy",
                            rotation: 180,
                            x: 1,
                            y: 1,
                            trigger: "load",
                            script: "lilguy"
                        },
                        "lilguy2": {
                            actor: "lilguy",
                            rotation: 90,
                            x: 2,
                            y: 1
                        }
                    }
                }
            ]
        },
            () => {
            })
    </script>
</body>

</html>